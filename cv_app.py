# -*- coding: utf-8 -*-
"""cv-app.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1tcjX5Ew_yMtFlaop1qWwec4mDTu9ufnj
"""

# Image Processing Playground using Streamlit

import streamlit as st
import cv2
import numpy as np
from PIL import Image

st.set_page_config(page_title="Image Processing Playground", layout="wide")
st.title("ðŸ§ª Image Processing Playground")
st.markdown("Upload an image and apply various image processing techniques interactively.")

# --- Image uploader ---
uploaded_file = st.file_uploader("Upload an Image", type=["jpg", "jpeg", "png"])

# --- Helper: Convert to OpenCV image ---
def load_image(img):
    img = Image.open(img).convert('RGB')
    return cv2.cvtColor(np.array(img), cv2.COLOR_RGB2BGR)

# --- Display original and processed images side-by-side ---
def show_images(original, processed, title_processed="Processed Image"):
    col1, col2 = st.columns(2)
    with col1:
        st.image(original, channels="BGR", caption="Original Image")
    with col2:
        st.image(processed, channels="BGR", caption=title_processed)

# --- Techniques ---
def apply_threshold(img, method):
    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
    if method == "Binary":
        _, result = cv2.threshold(gray, 127, 255, cv2.THRESH_BINARY)
    elif method == "Binary Inverted":
        _, result = cv2.threshold(gray, 127, 255, cv2.THRESH_BINARY_INV)
    elif method == "Truncate":
        _, result = cv2.threshold(gray, 127, 255, cv2.THRESH_TRUNC)
    elif method == "ToZero":
        _, result = cv2.threshold(gray, 127, 255, cv2.THRESH_TOZERO)
    elif method == "ToZero Inverted":
        _, result = cv2.threshold(gray, 127, 255, cv2.THRESH_TOZERO_INV)
    elif method == "Adaptive Mean":
        result = cv2.adaptiveThreshold(gray, 255, cv2.ADAPTIVE_THRESH_MEAN_C,
                                       cv2.THRESH_BINARY, 11, 2)
    elif method == "Adaptive Gaussian":
        result = cv2.adaptiveThreshold(gray, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C,
                                       cv2.THRESH_BINARY, 11, 2)
    elif method == "Otsu's":
        _, result = cv2.threshold(gray, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)
    return cv2.cvtColor(result, cv2.COLOR_GRAY2BGR)

def apply_blur(img, method, ksize):
    if method == "Averaging":
        return cv2.blur(img, (ksize, ksize))
    elif method == "Gaussian":
        return cv2.GaussianBlur(img, (ksize, ksize), 0)
    elif method == "Median":
        return cv2.medianBlur(img, ksize)
    elif method == "2D Convolution":
        kernel = np.ones((ksize, ksize), np.float32) / (ksize * ksize)
        return cv2.filter2D(img, -1, kernel)

def apply_edge_detection(img, method):
    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
    if method == "Sobel X":
        result = cv2.Sobel(gray, cv2.CV_64F, 1, 0, ksize=5)
    elif method == "Sobel Y":
        result = cv2.Sobel(gray, cv2.CV_64F, 0, 1, ksize=5)
    elif method == "Laplacian":
        result = cv2.Laplacian(gray, cv2.CV_64F)
    elif method == "Canny":
        result = cv2.Canny(gray, 100, 200)
    result = cv2.convertScaleAbs(result)
    return cv2.cvtColor(result, cv2.COLOR_GRAY2BGR)

# --- Main App Functionality ---
if uploaded_file:
    img = load_image(uploaded_file)

    st.sidebar.header("Select Technique")
    option = st.sidebar.selectbox("Technique", (
        "Thresholding",
        "Blurring & Smoothing",
        "Edge Detection",
        "Color Space Conversion",
    ))

    if option == "Thresholding":
        method = st.sidebar.selectbox("Method", [
            "Binary", "Binary Inverted", "Truncate", "ToZero", "ToZero Inverted",
            "Adaptive Mean", "Adaptive Gaussian", "Otsu's"])
        processed = apply_threshold(img, method)
        show_images(img, processed, f"Thresholding - {method}")

    elif option == "Blurring & Smoothing":
        method = st.sidebar.selectbox("Method", ["Averaging", "Gaussian", "Median", "2D Convolution"])
        ksize = st.sidebar.slider("Kernel Size (odd)", 1, 15, 5, step=2)
        processed = apply_blur(img, method, ksize)
        show_images(img, processed, f"Blurring - {method}")

    elif option == "Edge Detection":
        method = st.sidebar.selectbox("Method", ["Sobel X", "Sobel Y", "Laplacian", "Canny"])
        processed = apply_edge_detection(img, method)
        show_images(img, processed, f"Edge Detection - {method}")

    elif option == "Color Space Conversion":
        space = st.sidebar.selectbox("Color Space", ["Grayscale", "HSV", "RGB"])
        if space == "Grayscale":
            converted = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
            processed = cv2.cvtColor(converted, cv2.COLOR_GRAY2BGR)
        elif space == "HSV":
            processed = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)
        elif space == "RGB":
            processed = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
        show_images(img, processed, f"Color Space - {space}")